<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:batch="http://www.springframework.org/schema/batch"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
       http://www.springframework.org/schema/batch http://www.springframework.org/schema/batch/spring-batch-2.1.xsd">
	<!--
		TUTORIALES:
		
		http://unpocodejava.wordpress.com/2011/04/30/spring-batch-conceptos/
		http://www.dosideas.com/noticias/java/214-les-presentamos-spring-batch.html
		http://www.dosideas.com/cursos/course/view.php?id=7
		http://srlawr.blogspot.com.ar/2011/10/spring-batch-frameworks-simplest.html
	
	 -->
	
	
	<!-- 
		 ********************************
	     ********CONFIGURACION*********** 
	     ********************************
	-->
	
	<!-- 
		Un JobRepository es el encargado de almacenar información sobre la corrida de los Jobs.
		Vamos a utilizar la implementación MapJobRepositoryFactoryBean que guarda la información 
		de las ejecuciones en memoria.

		En una implementación real, donde se quiere guardar en forma persistente esta información, 
		se puede usar la implementación JobRepositoryFactoryBean la cual utiliza una base de datos 
		para almacenar toda la corrida. Spring Batch utiliza un modelo de datos con 
		tablas propias para este fin.
	 -->
	<bean id="jobRepository"
		class="org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean">
		<property name="transactionManager" ref="transactionManager" />
	</bean>
	
	<!-- 
		No es un bean propio de Spring Batch, pero lo utiliza el JobRepository para manejar 
		las transacciones. En este ejemplo, como no accederemos a ningún medio transaccional, 
		usaremos una implementación "dummy" del transaction manager ya provista por 
		Spring Batch, llamada ResourcelessTransactionManager. 
	-->
	<bean id="transactionManager"
		class="org.springframework.batch.support.transaction.ResourcelessTransactionManager" />

	<!--
		Los JobLaunchers son responsables de iniciar un trabajo con determinados parámetros. 
		Existe una implementación prevista, SimpleJobLauncher, que se basa en una TaskExecutor 
		para poner en marcha los trabajos. Si no específico TaskExecutor, se setea entonces 
		un SyncTaskExecutor para utilizarlo 
	 -->
	<bean id="jobLauncher"
		class="org.springframework.batch.core.launch.support.SimpleJobLauncher">
		<property name="jobRepository" ref="jobRepository" />
	</bean>

	<!-- 
		 ************************
	     ********JOB 9*********** 
	     ************************
	     
	  	Leyendo un XML
	  	
	  	http://static.springsource.org/spring-batch/reference/html/readersAndWriters.html
	  	
	  	Notice Spring Batch uses StAX, which means that the whole XML file won't be loaded in memory. 
	  	Spring Batch will "stream" it instead and send the Contact objects in chunks to the writer. 
	  	The size of the chunk will the value in the commit-interval attribute defined previously. 	  
	  	
	-->
	
	<batch:job id="xmlReadAndGeneratorStep" restartable="true">
        
        <batch:step id="readAndWriteXML">
            <batch:tasklet>
                <batch:chunk reader="readXml" processor="processXml" writer="writeXml"  commit-interval="4" />               
            </batch:tasklet>
        </batch:step>
        
    </batch:job>
    
    <bean id="readXml" class="org.springframework.batch.item.xml.StaxEventItemReader">
    	<property name="fragmentRootElementName" value="contact" />
    	<!--  property name="resource" value="classpath:com/springbatch/ejemplo9/input.xml" /-->
    	<property name="resource" ref="proccessInputResource" />
    	<property name="unmarshaller" ref="tradeMarshaller" />
	</bean>
	
	<bean id="proccessInputResource" class="org.springframework.core.io.FileSystemResource">
  		<constructor-arg value="/logs/input.xml"/>
	</bean>
	
	<!-- OPCION 1 -->
	<!--  bean id="tradeMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller">
		<property name="aliases">
			<map>
				<entry key="contact" value="com.springbatch.ejemplo9.Contact" />
			</map>
		</property>
	</bean-->
	
	<!-- OPCION 2 -->
	 <bean id = "tradeMarshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller">
        <property name = "classesToBeBound">
            <array>
                <value>com.springbatch.ejemplo9.Contact</value>
            </array>
        </property>
    </bean>
	
	<bean id="processXml" class="com.springbatch.ejemplo9.ProcessorItem"/>
	
	<!--  bean id="writeXml" class="com.springbatch.ejemplo9.ConsolaItemWriter"/-->
	
	<bean id="writeXml" class="org.springframework.batch.item.xml.StaxEventItemWriter">
	    <property name="resource" ref="proccessOutputResource" />
	    <property name="marshaller" ref="personMarshaller" />
	    <property name="rootTagName" value="ProvisioningOrders"/>
	    <property name="rootElementAttributes">
   			<map>
   				<entry key="xmlns:xsi" value="http://www.w3.org/2001/XMLSchema-instance"/>
   				<entry key="xsi:schemaLocation" value="http://www.gemalto.com/schema/pm pmBatchFile.xsd"/>
   				<entry key="xmlns" value=""/>
   				<entry key="generateReport" value="true"/>
   			</map>
 		</property>
	    <property name="overwriteOutput" value="true" />
	</bean>
	
	<bean id="proccessOutputResource" class="org.springframework.core.io.FileSystemResource">
  		<constructor-arg value="/logs/output.xml"/>
	</bean>
	
	<!-- OPCION 1 -->
	<!--  bean id="personMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller">
		<property name="aliases">
			<map>
				<entry key="order" value="com.springbatch.ejemplo9.Orde" />
			</map>
		</property>
	</bean-->
	
	
	<!-- OPCION 2 -->
    <bean id = "personMarshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller">
        <property name = "classesToBeBound">
            <array>
                <value>com.springbatch.ejemplo9.Order</value>
            </array>
        </property>
    </bean>
	
</beans>