<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:batch="http://www.springframework.org/schema/batch"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
       http://www.springframework.org/schema/batch http://www.springframework.org/schema/batch/spring-batch-2.1.xsd">
	<!--
		TUTORIALES:
		
		http://unpocodejava.wordpress.com/2011/04/30/spring-batch-conceptos/
		http://www.dosideas.com/noticias/java/214-les-presentamos-spring-batch.html
		http://www.dosideas.com/cursos/course/view.php?id=7
		http://srlawr.blogspot.com.ar/2011/10/spring-batch-frameworks-simplest.html
	
	 -->
	
	
	<!-- 
		 ********************************
	     ********CONFIGURACION*********** 
	     ********************************
	-->
	
	<!-- 
		No es un bean propio de Spring Batch, pero lo utiliza el JobRepository para manejar 
		las transacciones. En este ejemplo, como no accederemos a ningún medio transaccional, 
		usaremos una implementación "dummy" del transaction manager ya provista por 
		Spring Batch, llamada ResourcelessTransactionManager. 
	-->
	<bean id="transactionManager"
		class="org.springframework.batch.support.transaction.ResourcelessTransactionManager" />

	<!-- 
		Un JobRepository es el encargado de almacenar información sobre la corrida de los Jobs.
		Vamos a utilizar la implementación MapJobRepositoryFactoryBean que guarda la información 
		de las ejecuciones en memoria.

		En una implementación real, donde se quiere guardar en forma persistente esta información, 
		se puede usar la implementación JobRepositoryFactoryBean la cual utiliza una base de datos 
		para almacenar toda la corrida. Spring Batch utiliza un modelo de datos con 
		tablas propias para este fin.
	 -->
	<bean id="jobRepository"
		class="org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean">
		<property name="transactionManager" ref="transactionManager" />
	</bean>

	<!--
		Los JobLaunchers son responsables de iniciar un trabajo con determinados parámetros. 
		Existe una implementación prevista, SimpleJobLauncher, que se basa en una TaskExecutor 
		para poner en marcha los trabajos. Si no específico TaskExecutor, se setea entonces 
		un SyncTaskExecutor para utilizarlo 
	 -->
	<bean id="jobLauncher"
		class="org.springframework.batch.core.launch.support.SimpleJobLauncher">
		<property name="jobRepository" ref="jobRepository" />
	</bean>

	<!-- 
		 ************************
	     ********JOB 1*********** 
	     ************************
	-->
	
	<!-- Vamos a definir nuestro primer Job
		 Una trabajo de Spring Batch.
         Este es el bean principal de Spring Batch, que declara el trabajo batch
         que se va a ejecutar. El trabajo está compuesta de varios "pasos" (step).
         Los pasos se ejecutan en forma secuencial.
		 
		 Usaremos la implementación SimpleJob que ejecuta todos los pasos de sequencialmente. 
		 Con el fin de conectar un tasklet a un Job, necesitamos un TaskletStep. Es 
		 decir, a continuación agregaremos a nuestra configuración anterior: 
			A. Un SimpleJob 
			B. Tres TaskletStep, que referencian a nuestros Tasklet 
			C. Tres Tasklet, configurados para imprimir distintos mensajes 
	-->
	
	<batch:job id="trabajoBatch">
		<batch:step id="primerPaso" next="segundoPaso">
			<batch:tasklet ref="imprimirHola" />
		</batch:step>
		<batch:step id="segundoPaso" next="tercerPaso">
			<batch:tasklet ref="imprimirMundo" />
		</batch:step>
		<batch:step id="tercerPaso">
			<batch:tasklet ref="imprimirExclamacion" />
		</batch:step>
	</batch:job>
	
	<bean id="imprimirHola" class="com.springbatch.ejemplo1.ImprimirTasklet">
		<property name="mensaje" value="Hola, " />
	</bean>

	<bean id="imprimirMundo" class="com.springbatch.ejemplo1.ImprimirTasklet">
		<property name="mensaje" value="Mundo" />
	</bean>

	<bean id="imprimirExclamacion" class="com.springbatch.ejemplo1.ImprimirTasklet">
		<property name="mensaje" value="!!!" />
	</bean>


	<!-- 
		 ************************
	     ********JOB 2*********** 
	     ************************
	     
	    En este ejemplo, el trabajo consiste en un único paso "trabajoBatch2".
        Este paso tiene un "itemReader" que lee planetas y los mapea a un objeto
        Planeta, y un "itemWriter" que imprimir objetos Planeta por consola.
        
        NOTA: Otra forma simplificada de escribir lo mismo de arriba, pero utilizando
        ItemWriter en lugar de Tasklet
	-->
	
	<batch:job id="trabajoBatch2" restartable="true">
        <batch:step id="imprimirPorConsola">
            <batch:tasklet>
                <batch:chunk reader="planetaItemReader" writer="consolaItemWriter" commit-interval="5"/>
            </batch:tasklet>
        </batch:step>
    </batch:job>
	
	<!--
        Lector de planteas. Esta reader de archivos planos es una clase
        utilitaria provista por Spring Batch. Este bean lee el archivo
        "planetas.csv". El atributo "lineMapper" indica la composicion del
        archivo (en este caso, separado por comas "," y con los nombres de
        cada una de las columnas.
        El atributo "fileSetMapper" es el encargado de convertir cada linea del
        archivo a un objeto. En este caso se utiliza una clase utilitaria de
        Spring Batch para convertir cada columna a un objeto Planeta. Esta clase
        utilitaria utiliza los nombres de columna como nombres de atributos
        en el objeto Planeta destino.
        
        Spring Batch viene por defecto con diferentes tipos de Readers para leer ficheros planos, XML o datos 
        de base de datos. Estos Readers se configuran con una especie de mapeo entre registros y objetos.
    -->
    <bean id="planetaItemReader" class="org.springframework.batch.item.file.FlatFileItemReader">
        <property name="resource" value="classpath:com/springbatch/ejemplo2/planetas.csv"/>
        <property name="lineMapper">
            <bean class="org.springframework.batch.item.file.mapping.DefaultLineMapper">
                <property name="lineTokenizer">
                    <bean class="org.springframework.batch.item.file.transform.DelimitedLineTokenizer">
                        <property name="delimiter" value="," />
                        <property name="names" value="Codigo, Nombre, Diametro, Tipo, Significado"/>
                    </bean>
                </property>
                <property name="fieldSetMapper">
                    <bean class="org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper">
                        <property name="prototypeBeanName" value="planeta"/>
                    </bean>
                </property>
            </bean>
        </property>
    </bean>
    
    <!--
        Esta es la clase encargada de escribir los resultados de la lectura
        del "itemReader". Cada elemento leido por el "planetaItemReader" es
        procesado por este "itemWriter".
        ConsolaItemWriter recibe entonces un Planeta y lo muestra por consola.
    -->
    <bean id="consolaItemWriter" class="com.springbatch.ejemplo2.ConsolaItemWriter"/>
    
     <!--
        Este bean es usado por "planetaItemReader" (en particular, por su
        fieldSetMapper), para convertir cada línea del archivo de origen a un
        objeto.
        Su scope TIENE que ser "prototype", ya que se necesita una instancia
        nueva por cada invocación.
     -->
    <bean id="planeta" scope="prototype" class="com.springbatch.ejemplo2.Planeta"/>
    

	<!--
	
	 	 ************************
	     ********JOB 3*********** 
	     ************************
	     
        En este ejemplo, el trabajo consiste en un unico paso "convertirArchivo".
        Este paso tiene un "itemReader" que lee planetas y los mapea a un objeto
        Planeta, y un "itemWriter" que guarda algunos datos de cada Planeta
        en un nuevo archivo plano.
    -->
    <batch:job id="trabajoBatch3">
        <batch:step id="convertirArchivo">
            <batch:tasklet>
                <batch:chunk reader="planetaItemReader2" writer="archivoPlanoItemWriter" commit-interval="5" />
            </batch:tasklet>
        </batch:step>
    </batch:job>
    
    <!--
        Lector de planteas. Esta reader de archivos planos es una clase
        utilitaria provista por Spring Batch. Este bean lee el archivo
        "planetas.csv". El atributo "lineMapper" indica la composicion del
        archivo (en este caso, separado por comas "," y con los nombres de
        cada una de las columnas.
        El atributo "fileSetMapper" es el encargado de convertir cada linea del
        archivo a un objeto. En este caso se utiliza una clase utilitaria de
        Spring Batch para convertir cada columna a un objeto Planeta. Esta clase
        utilitaria utiliza los nombres de columna como nombres de atributos
        en el objeto Planeta destino.
    -->
    <bean id="planetaItemReader2" class="org.springframework.batch.item.file.FlatFileItemReader">
        <property name="resource" value="classpath:com/springbatch/ejemplo2/planetas.csv"/>
        <property name="lineMapper">
            <bean class="org.springframework.batch.item.file.mapping.DefaultLineMapper">
                <property name="lineTokenizer">
                    <bean class="org.springframework.batch.item.file.transform.DelimitedLineTokenizer">
                        <property name="delimiter" value="," />
                        <property name="names" value="Codigo, Nombre, Diametro, Tipo, Significado"/>
                    </bean>
                </property>
                <property name="fieldSetMapper">
                    <bean class="org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper">
                        <property name="prototypeBeanName" value="planeta"/>
                    </bean>
                </property>
            </bean>
        </property>
    </bean>
    
     <!--
        Esta es la clase encargada de escribir los resultados de la lectura
        del "itemReader". Cada elemento leido por el "planetaItemReader" es
        procesado por este "itemWriter".
        "archivoPlanoItemWriter" recibe un Planeta y guarda solo algunos datos
        del planeta en el archivo "planetas-resultado-demo2.txt", separada
        cada columna por el caracter ";".

        El atributo "resource" indica dÃ³nde se guardarÃ¡ el archivo resultante.
        En este caso, serÃ¡ en la raiz de este mismo proyecto.
        El atributo "lineAggregator" indica cuÃ¡l serÃ¡ el delimitador de valores
        dentro de cada lÃ­nea.
        El atributo "fieldExtractor" es el encargado de recibir el Planeta
        (creado por "planetaItemReader") y devolver los valores que conformarÃ¡n
        una lÃ­nea en el archivo de texto.
    -->
    <bean id="archivoPlanoItemWriter" class="org.springframework.batch.item.file.FlatFileItemWriter">
        <property name="resource" value="file:planetas-resultado-demo2.txt"/>
        <property name="shouldDeleteIfExists" value="true"/>
        <property name="lineAggregator">
            <bean class="org.springframework.batch.item.file.transform.DelimitedLineAggregator">
                <property name="delimiter" value="|"/>
                <property name="fieldExtractor">
                    <bean class="org.springframework.batch.item.file.transform.BeanWrapperFieldExtractor">
                        <property name="names" value="codigo,nombre,significado"/>
                    </bean>
                </property>
            </bean>
        </property>
    </bean>
	
	<!--
	
	 	 ************************
	     ********JOB 4*********** 
	     ************************
	     
 		En este ejemplo, el trabajo consiste en un unico paso "imprimirPorConsola2".
        Este paso tiene un "itemReader" que lee planetas de la BD y los mapea a un objeto
        Planeta, y un "itemWriter" que imprimir objetos Planeta por consola.

    -->
    <batch:job id="trabajoBatch4">
        <batch:step id="imprimirPorConsola2">
            <batch:tasklet>
                <batch:chunk reader="planetaReader" writer="planetaWriter" commit-interval="5" />
            </batch:tasklet>
        </batch:step>
    </batch:job>
    
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="oracle.jdbc.OracleDriver"/>
        <property name="url" value="jdbc:oracle:thin:@localhost:1521:XE"/>
        <property name="username" value="prueba"/>
        <property name="password" value="prueba"/>
    </bean>
    
     <!--
        Lector de planteas. Esta reader de base de datos es una clase 
        utilitaria provista por Spring Batch. Este bean ejecuta el query "sql"
        y recorrer las filas resultantes. Cada fila es transformada con el
        "mapper" asociado. 
        En este caso se usa un mapper utilitario, que de acuerdo al alias
        indicado en cada columna del query lo asocia a un objeto Planeta.
    -->
    <bean id="planetaReader" class="org.springframework.batch.item.database.JdbcCursorItemReader">
        <property name="dataSource" ref="dataSource" />
        <property name="sql" value="select id_planeta as codigo, nombre as nombre, diametro as diametro, tipo as tipo, observaciones as significado from PLANETA"/>
        <property name="rowMapper">
            <bean id="planetaMapper" class="org.springframework.jdbc.core.BeanPropertyRowMapper">
                <property name="mappedClass">
                      <value type="java.lang.Class">com.springbatch.ejemplo4.Planeta</value>
                </property>
            </bean>
        </property>
    </bean>
    
    <!--
        Esta es la clase encargada de escribir los resultados de la lectura
        del "itemReader". Cada elemento leido por el "planetaItemReader" es
        procesado por este "itemWriter". 
        ConsolaItemWriter recibe entonces un Planeta y lo muestra por consola.
    -->
    <bean id="planetaWriter" class="com.springbatch.ejemplo4.ConsolaItemWriter"/>
    
    <!--
	
	 	 ************************
	     ********JOB 6*********** 
	     ************************
	     
 		En este ejemplo, el trabajo consiste en un unico paso "imprimirPorConsolaElResultado".
        Este paso tiene un "itemReader10" que lee planetas y los mapea a un objeto
        Planeta, y un "itemWriter10" que imprime objetos Planeta por consola.

        Al step "imprimirPorConsolaElResultado" se le configura un taskExecutor que realiza
        un procesamiento asincronico del mismo, con 3 elementos concurrentes.
        De esta manera, este step se ejecuta con 3 threads. Al terminar estos
        3 threads de ejecutarse (cuando el itemReader10 devuelva null, por no haber
        mas elementos), se ejecutara el siguiente step (en este caso, no hay
        ningun otro step para ejecutar).

    -->
    
     <batch:job id="trabajoBatchMultithread">
        <batch:step id="imprimirPorConsolaElResultado">
            <batch:tasklet task-executor="miTaskExecutor"> <!-- De esta manera indicamos q este STEP se haga en paralelo por varios threads -->
                <batch:chunk reader="itemReader10"
                             writer="itemWriter10"
                             commit-interval="5"> 
                </batch:chunk>
            </batch:tasklet>
        </batch:step>
    </batch:job>
    
    <bean id="miTaskExecutor" class="org.springframework.core.task.SimpleAsyncTaskExecutor" >
        <property name="concurrencyLimit" value="5" /> <!-- Indicamos la cantidad de threads que se ejecutaran -->
    </bean>
    
    <bean id="itemReader10" class="org.springframework.batch.item.file.FlatFileItemReader">
        <property name="resource" value="classpath:com/springbatch/ejemplo6/planetas.csv"/>
        <property name="lineMapper">
            <bean class="org.springframework.batch.item.file.mapping.DefaultLineMapper">
                <property name="lineTokenizer">
                    <bean class="org.springframework.batch.item.file.transform.DelimitedLineTokenizer">
                        <property name="delimiter" value="," />
                        <property name="names" value="Codigo, Nombre, Diametro, Tipo, Significado"/>
                    </bean>
                </property>
                <property name="fieldSetMapper">
                    <bean class="org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper">
                        <property name="prototypeBeanName" value="planeta10"/>
                    </bean>
                </property>
            </bean>
        </property>
    </bean>
    
    <bean id="itemWriter10" class="com.springbatch.ejemplo6.ConsolaItemWriter"/>
    
 	 <!--
        Este bean es usado por "itemReader10" (en particular, por su
        fieldSetMapper), para convertir cada lÃ­nea del archivo de origen a un
        objeto.
        Su scope TIENE que ser "prototype", ya que se necesita una instancia
        nueva por cada invocaciÃ³n.
     -->
    <bean id="planeta10" scope="prototype" class="com.springbatch.ejemplo6.Planeta"/>

    <!--
	
	 	 ************************
	     ********JOB 7*********** 
	     ************************
	     
 		En este ejemplo, el trabajo consiste en un unico paso "imprimirPorConsolaElResultado".
        Este paso tiene un "itemReader10" que lee planetas y los mapea a un objeto
        Planeta, y un "itemWriter10" que imprime objetos Planeta por consola.

        Idem al JOB 6 pero en lugar de leer de una archivo vamos a leer de una bd de forma concurrente
		
		IMPORTANTE: NO ANDA YA Q CADA THREAD VA A INTENTAR TIRAR LA MIMSA QUERY
		
		org.springframework.jdbc.UncategorizedSQLException: Attempt to process next row failed; uncategorized 
		SQLException for SQL [select id_planeta as codigo, nombre as nombre, diametro as diametro, tipo as tipo, 
		observaciones as significado from PLANETA]; SQL state [null]; error code [17011]; Exhausted Resultset; 
		nested exception is java.sql.SQLException: Exhausted Resultset
		
    -->	
    
    <batch:job id="trabajoBatchMultithread2">
        <batch:step id="imprimirPorConsolaElResultado2">
            <batch:tasklet task-executor="miTaskExecutor2"> 
                <batch:chunk reader="itemReader20"
                             writer="itemWriter20"
                             commit-interval="5"> 
                </batch:chunk>
            </batch:tasklet>
        </batch:step>
    </batch:job>
    
    <bean id="miTaskExecutor2" class="org.springframework.core.task.SimpleAsyncTaskExecutor" >
        <property name="concurrencyLimit" value="1" /> <!-- Indicamos la cantidad de threads que se ejecutaran -->
    </bean>
    
     <bean id="itemReader20" class="org.springframework.batch.item.database.JdbcCursorItemReader">
        <property name="dataSource" ref="dataSource" />
        <property name="sql" value="select id_planeta as codigo, nombre as nombre, diametro as diametro, tipo as tipo, observaciones as significado from PLANETA"/>
        <property name="rowMapper">
            <bean id="planetaMapper2" class="org.springframework.jdbc.core.BeanPropertyRowMapper">
                <property name="mappedClass">
                      <value type="java.lang.Class">com.springbatch.ejemplo7.Planeta</value>
                </property>
            </bean>
        </property>
    </bean>
    
    <bean id="itemWriter20" class="com.springbatch.ejemplo7.ConsolaItemWriter"/>
    
    
    
	<!-- 
		 ************************
	     ********JOB 8*********** 
	     ************************
	     
	  	Leyendo un XML
	  	
	  	http://static.springsource.org/spring-batch/reference/html/readersAndWriters.html
	  	
	  	Notice Spring Batch uses StAX, which means that the whole XML file won't be loaded in memory. 
	  	Spring Batch will "stream" it instead and send the Contact objects in chunks to the writer. 
	  	The size of the chunk will the value in the commit-interval attribute defined previously. 	  
	  	
	-->
	
	<batch:job id="trabajoBatch999" restartable="true">
        
        <batch:step id="imprimirPorConsolaElXml" next="obtenerXmlYHacerAlgo">
            <batch:tasklet>
                <batch:chunk reader="xmlItemReader" writer="consolaXmlItemWriter"  commit-interval="4" />               
            </batch:tasklet>
            <batch:listeners><!--  NOTA esto hace q se publique el parametro que vamos a pasar al siguiente step -->
        		<batch:listener ref="promotionListener"/>
        	</batch:listeners>
<!--             <batch:next on="*" to="obtenerXmlYHacerAlgo"/>   En caso de exito, vamos por aca -->
<!-- 	        <batch:next on="FAILED" to="loguearError"/> 	 En caso de fracaso, vamos por este otro step. Para probar esto podemos tocar el XML y q nos tire erro de pareso -->
        </batch:step>
        
        <batch:step id="obtenerXmlYHacerAlgo" next="loguearError">
			<batch:tasklet ref="retriveXMLAndDoSomething" />
		</batch:step>
		
		<batch:step id="loguearError">
			<batch:tasklet ref="logError" />
		</batch:step>
        
    </batch:job>
    
    <bean id="xmlItemReader" class="org.springframework.batch.item.xml.StaxEventItemReader">
    	<property name="fragmentRootElementName" value="contact" />
    	<property name="resource" value="classpath:com/springbatch/ejemplo8/input.xml" />
    	<property name="unmarshaller" ref="tradeMarshaller" />
	</bean>
	
	<bean id="tradeMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller">
		<property name="aliases">
			<map>
				<entry key="contact" value="com.springbatch.ejemplo8.Contact" />
			</map>
		</property>
	</bean>
	
	<bean id="consolaXmlItemWriter" class="com.springbatch.ejemplo8.ConsolaItemWriter"/>
	
	<bean id="promotionListener" class="org.springframework.batch.core.listener.ExecutionContextPromotionListener">
    	<property name="keys" value="xml"/> <!-- ATENCION: aca le ponemos el value a la property keys. Esta value sera el mismo q
    											 utilizaremkos tanto para hacer el put en el contexto como al hacer el get del contexto -->
	</bean>
	
	<bean id="retriveXMLAndDoSomething" class="com.springbatch.ejemplo8.RetriveXMLAndDoSomething"/>
	
	<bean id="logError" class="com.springbatch.ejemplo8.LogError"/>
	
</beans>