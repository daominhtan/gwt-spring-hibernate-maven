<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/security"
    xmlns:beans="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
                    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                    http://www.springframework.org/schema/security 
                    http://www.springframework.org/schema/security/spring-security-3.0.xsd">
 
 	<!-- SPRING SECURITY -->
 	<!-- It is generally good practice to deny access by default, rather than only securing the resources we need.
 		 	Ver:http://static.springsource.org/spring-security/site/tutorial.html
 		 To use expressions to secure individual URLs, you would first need to set the use-expressions attribute in the <http> 
 		 element to true. Spring Security will then expect the access attributes of the <intercept-url> elements to contain 
 		 Spring EL expressions.
 		 
 		 El atributo use-expressions="true" permite activar las siguientes expresiones:
 		 	
 		 	hasRole([role])	Returns true if the current principal has the specified role.
			hasAnyRole([role1,role2])	Returns true if the current principal has any of the supplied roles (given as a comma-separated list of strings)
			principal	Allows direct access to the principal object representing the current user
			authentication	Allows direct access to the current Authentication object obtained from the SecurityContext
			permitAll	Always evaluates to true
			denyAll	Always evaluates to false
			isAnonymous()	Returns true if the current principal is an anonymous user
			isRememberMe()	Returns true if the current principal is a remember-me user
			isAuthenticated()	Returns true if the user is not anonymous
			isFullyAuthenticated()	Returns true if the user is not an anonymous or a remember-me user		 
 	 -->
	<http auto-config="true" use-expressions="true">
		<!-- Esto me securiza la siguiente URL: http://127.0.0.1:8888/mygwtmavensampleapp/ donde recide el JS -->
        <intercept-url pattern="/mygwtmavensampleapp/**" access="isAuthenticated()"/>
        <!-- Esto me securiza la siguiente URL: http://127.0.0.1:8888/mygwtmavensampleapp/gwt donde recide los recursos (css, imagenes, etc) -->
        <intercept-url pattern="/gwt/**" access="isAuthenticated()"/>
        <!-- Esto me securiza la siguiente URL: http://127.0.0.1:8888/MyGwtMavenSampleApp.html que seria el entry point de la app -->
        <intercept-url pattern="/*.html" access="isAuthenticated()"/>
        <intercept-url pattern="/login/*" access="permitAll" />
        <!-- Aqui redefinimos el form de login -->
        <form-login login-page="/login/login.jsp"        			
        			authentication-failure-url="/login/login.jsp?login_error=1" />    
        <logout logout-success-url="/login/login.jsp"/> 
        <!-- I want to redirect users to the login page when a session timeout occurs. This works out-of-the-box with spring security, 
        	 but only on non-ajax calls. On an ajax-call you have to react on the session timeout by yourself. 
         	 	Ver: http://stackoverflow.com/questions/6922211/spring-security-sesson-timeout-not-recognized-on-ajax-call
        	 	Ver: http://stackoverflow.com/questions/9406029/gwt-spring-security-session-timeout 
        	 	Ver: http://stackoverflow.com/questions/4964145/detect-session-timeout-in-ajax-request-in-spring-mvc 
        	 	Ver: http://groups.google.com/group/google-web-toolkit/browse_thread/thread/7be4c1ef82addefc/233073a6bdf336a2?lnk=gst&q=invalid+session#233073a6bdf336a2
        	 	Ver: http://forum.springsource.org/showthread.php?84779-How-to-Inform-User-That-session-has-timed-out -->
        <!-- No nos va a permitir loguear a mas de dos usuarios -->	 	
        <session-management>
        	<concurrency-control max-sessions="2" error-if-maximum-exceeded="true" expired-url="/login/login.jsp" /> 
        </session-management>	 	
    </http>
    
    <!-- 
    	Securizacion a nivel de metodos de los servicios (capa de servicios):   	    	
    	There are four annotations which support expression attributes to allow pre and post-invocation authorization checks 
        and also to support filtering of submitted collection arguments or return values. 
        They are @PreAuthorize, @PreFilter, @PostAuthorize and @PostFilter.
        Ejemplo1 : @PreAuthorize("hasRole('ROLE_USER')")
        Ejemplo2 : Supongamos que disponemos de un método de consulta de facturas de clientes. Resulta que dentro de los requisitos de 
        		   seguridad de la aplicación, se define que únicamente los administradores pueden imprimir facturas superiores a 5000 €.
        				@PreAuthorize(“hasRole(‘ADMIN’) and #factura.importe>5000″)
						public void imprimir(Factura factura); 
    -->
    <global-method-security pre-post-annotations="enabled"/>
    
    <!-- 
    	All the authentication requests are handled by an AuthenticationManager, so an instance of that has to be declare 
    	in our file. More specifically, the requests are usually delegated to an AuthenticationProvider. Some already created 
    	implementations can be used, such as the DaoAuthenticationProvider (when working with roles and users defined in a DB) 
    	or the LdapAuthenticationProvider (which authenticates users against an LDAP server). 
    	We are going to create a custom authentication provider and integrate it with spring's security infrastructure.
			Ver: http://www.javacodegeeks.com/2010/12/securing-gwt-apps-with-spring-security.html#ixzz1pwrddaE7
     -->
    <authentication-manager alias="authenticationManager">
	    <authentication-provider user-service-ref="customUserDetailsService" ref="customAuthenticationProvider"/>
	</authentication-manager>
	
	<beans:bean id="customAuthenticationProvider" class="au.com.uptick.gwt.maven.sample.server.auth.CustomAuthenticationProvider" />
	
	<!-- SPRING SECURITY -->
    
</beans:beans>  